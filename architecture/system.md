# ⛩️

## 参考

🗄 `databases.md` perf
📙 Bueno mature optimization https://carlos.bueno.org/optimization/

## 进步

---

* db per tentant https://news.ycombinator.com/item?id=39004963
* db per user https://news.ycombinator.com/item?id=38171322
* https://maheshba.bitbucket.io/blog/2023/07/12/Design.html
* https://read.engineerscodex.com/p/how-instagram-scaled-to-14-million
* race condition https://portswigger.net/research/smashing-the-state-machine
* state machine, audit https://blog.lawrencejones.dev/state-machines/ https://www.youtube.com/watch?v=YSUxLRlTzZ4
* cellular https://news.ycombinator.com/item?id=37274871
* https://news.ycombinator.com/item?id=36208420
* https://github.com/karanpratapsingh/system-design
* https://davidvujic.blogspot.com/2023/08/kafka-messaging-with-python-and-polylith.html
* https://www.youtube.com/watch?v=rIt0uj8TaKg
* incentives https://news.ycombinator.com/item?id=36380711&utm_term=comment
* https://www.benkuhn.net/progessays/
* 🗄 notebook 23.01.11
* https://sre.google/sre-book/table-of-contents/ definition of production readiness https://www.thoughtworks.com/radar/techniques?blipid=202203026
* https://news.ycombinator.com/item?id=32319147
* https://www.youtube.com/channel/UCDankIVMXJEkhtjv5yLSN4g/videos
* do with the Golang microservices book https://news.ycombinator.com/item?id=34572263
* https://news.ycombinator.com/item?id=34612919
* https://www.youtube.com/@AsliEngineering/videos
* things you need in an app https://www.amazon.com/Become-Awesome-Software-Architect-Foundation/dp/1697271065
* course on microservices https://www.youtube.com/watch?v=hmkF77F9TLw https://www.youtube.com/watch?v=NVvIpqmf_Xc
* https://brooker.co.za/blog/
* https://runninginproduction.com/podcast/
* db https://news.ycombinator.com/item?id=34434025
* soft delete https://news.ycombinator.com/item?id=32156009 https://brandur.org/soft-deletion https://brandur.org/fragments/deleted-record-insert
* https://www.youtube.com/watch?v=Y-Gl4HEyeUQ
* https://www.youtube.com/watch?v=a2rcgzludDU
* https://jameslittle.me/blog/2020/about-the-guestbook/
* https://benhoyt.com/writings/io-is-no-longer-the-bottleneck/
* https://news.ycombinator.com/item?id=29727707
* https://www.natemeyvis.com/software-design/ https://www.natemeyvis.com/an-argument-from-jimmy-koppel/
* https://simonwillison.net/2022/Feb/9/single-dependency-stacks/
* https://www.semicolonandsons.com/series/learn-system-design-for-web
* https://sirupsen.com/napkin/problem-2
* https://mattsegal.dev/django-prod-architectures.html
* https://github.com/sirupsen/napkin-math https://sirupsen.com/napkin/problem-7
* https://anthonynsimon.com/blog/one-man-saas-architecture/
* https://sirupsen.com/napkin/problem-1
* deploy Django w/ Google Cloud Run https://news.ycombinator.com/item?id=24705668
* https://maheshba.bitbucket.io/blog/2021/10/19/42Things.html
* https://calpaterson.com/bank-python.html
* interviewing https://www.youtube.com/playlist?list=PLrtCHHeadkHptUb0gduz9pxLgvtKWznKj
* rf monitoring re: `link.md` 'speed'
* Kleppmann 1.5 (db, cache, search, MQ)
> ❓ where are you with Kleppmann notes? thought that everything from section 1 has been put into notes, why is there a section for him under 'architecture'?
* https://12factor.net/
* https://increment.com/software-architecture/
* taxonomize https://mattsegal.dev/django-prod-architectures.html
* http://aosabook.org/en/distsys.html
* https://github.com/zachvalenta/nginx-wsgi - general refactor for 1) Poetry 2) Caddy
* https://robertheaton.com/2020/04/06/systems-design-for-advanced-beginners/
* rf 'next'
* architecture - https://www.cosmicpython.com/book/preface.html
* Kleppmann chapter 1 notes @ 14 -> `math.md` distributions
* servers - Nginx - https://github.com/zachvalenta/nginx-wsgi https://serverfault.com/q/821284/415712 https://stackoverflow.com/a/25486871/6813490
* servers - Nginx - tune https://blog.codeship.com/tuning-nginx/
* servers - BYO https://defn.io/2018/02/25/web-app-from-scratch-01/ http://joaoventura.net/blog/2017/python-webserver/
* interviewing - system design - https://github.com/donnemartin/system-design-primer https://github.com/madd86/awesome-system-design https://www.youtube.com/watch?v=VYuToviSx5Q
* https://news.ycombinator.com/item?id=26300191
* https://man.sr.ht/ops/ https://bible-api.com/ https://github.com/seven1m/bible_api https://robertheaton.com/2020/04/06/systems-design-for-advanced-beginners/
* security https://www.freecodecamp.org/learn/information-security/information-security-projects/stock-price-checker
* caching https://mattsegal.dev/simple-django-deployment.html
* infra https://mattsegal.dev/simple-django-deployment.html

ROADMAPS
https://roadmap.sh/system-design
https://roadmap.sh/software-architect
https://roadmap.sh/software-design-architecture
* CQRS, service mesh, SOA, scaling (back pressure, throttling) https://roadmap.sh/backend

WALKTHROUGHS
* https://www.youtube.com/channel/UCDankIVMXJEkhtjv5yLSN4g/videos
* https://www.youtube.com/playlist?list=PL8hP5HjAnJ3_mT7IHXjlbpYX_xiz4v_kP
* Heroku clone https://www.youtube.com/watch?v=zhJLVFR3pE8
* Netflix clone https://www.youtube.com/watch?v=gbyYXgiSgdM
* Facebook clone https://www.youtube.com/watch?v=xSUm6iMtREA
* PagerDuty clone https://www.youtube.com/watch?v=4xuBT3BbsYU alerts https://github.com/keephq/keep

# 🎯 APPROACHES

📙 Percival https://www.amazon.com/gp/product/1492052205
> Also, as a general rule, you can at any given time get away with changing more than you think. Introducing change is like pulling off a bandage: the pain is a memory almost as soon as you feel it. http://paulgraham.com/popular.html
🗄
* `db.md` migrations, scaling
* `language.md` design
* `science.md` complexity

---

KLEPPMANN
* _reliability_: works even if hw/sw failure [6]
* _scalability_: able to deal w/ growth (data, traffic, complexity)
* _maintainability_: other devs able to work on system
> it is well know that the majority of the cost of software is not in its intial development, but its ongoing maintenance [Kleppmann 18] https://www.jefftk.com/p/designing-low-upkeep-software
* _db on 1 machine_: requires planned downtime [8]
* _db on n machines_: can do rolling upgrade [8]
* _n db_:
* _things that can go wrong_: runaway process (consuming too much memory) [8] unresponsive downstream service [9] operator error [9]
* _how to prevent things going wrong_: testing https://danluu.com/why-benchmark/ easy rollback, monitoring
* _fan out_: num of req to other services to handle one incoming req [11]
📍 need to review SQL of Twitter example
* _evolvability_: ability to change different parts of system independently [Kleppmann 4.128]

TAXONOMY
* _monolith_: single service, single data store https://news.ycombinator.com/item?id=24505467
* _SOA (service oriented)_: n services, n data stores
* _DOA (data oriented)_: n services, single data store https://blog.eyas.sh/2020/03/data-oriented-architecture/ https://changelog.com/podcast/522

ZA
* layered architecture https://blog.europython.eu/kraken-technologies-how-we-organize-our-very-large-pythonmonolith/
* modular https://github.com/gauge-sh/tach https://www.piglei.com/articles/en-6-ways-to-improve-the-arch-of-you-py-project/
> A Python tool to enforce a modular, decoupled package architecture. tach allows you to define boundaries and control dependencies between your Python packages. Each package can define its public interface. If a package tries to import from another package that is not listed as a dependency, tach will report an error. If a package tries to import from another package and does not use its public interface, with strict: true set, tach will report an error. Zero runtime impact. https://pythonbytes.fm/episodes/show/384/force-push-lightly
* beware theologians https://news.ycombinator.com/item?id=26492798
* _patterns_: MVC, hexagonal https://blog.carlmjohnson.net/post/2020/go-cli-how-to-and-advice/ https://netflixtechblog.com/ready-for-changes-with-hexagonal-architecture-b315ec967749
* _resiliency_: perform job through failure https://leanpub.com/systemdesignmanual/read_sample
* Lisp, database inside codebase https://news.ycombinator.com/item?id=26160186 https://feifan.blog/posts/the-database-inside-your-codebase
* _kill switch_: force upgrade mobile app https://simonwillison.net/2021/Jul/1/pagnis/
* _bounded context_: don't let a word mean two different things in the same part of the system ex. 'account' inside primary system vs. 'account' during Paypal integration; again, duh
* _circuit breaker_: error handling https://github.com/Netflix/Hystrix/wiki/How-it-Works https://www.gremlin.com/chaos-monkey/ https://pypi.org/project/circuitbreaker/ https://sirupsen.com/napkin/problem-11-circuit-breakers
* e.g. downstream call fails, return empty list instead of 404 and poll downstream, have limits on resources devoted to downstream
* avoid fault in one part of a system taking down the system
* _coupling_: one change necessitates another
* _horizontal scaling_: aka shared-nothing architecture [Kleppmann 17]
* _multi-tenant_: multiple customer users https://www.saaspegasus.com/
* Edge, Sentry, Parse https://www.youtube.com/watch?v=W1fkGyIcePA&t=1044s https://www.pythonpodcast.com/datacoral-serverless-technology-episode-214/ 15:00-19:00 https://www.youtube.com/watch?v=OfPE7yj1trw https://www.viget.com/articles/multi-tenancy-in-django
* _service mesh_: https://servicemesh.io/ https://news.ycombinator.com/item?id=17415421 https://www.digitalocean.com/community/tutorials/an-introduction-to-service-meshes sidecar, eBPF https://www.thoughtworks.com/radar/techniques?blipid=202203060 Istio
* data mesh https://news.ycombinator.com/item?id=30721198 https://www.thoughtworks.com/radar/techniques?blipid=201911051
* _SSoT_: single source of truth
* _SPoF_: single point of failure
* _fault domain_: components sharing SPoF https://lethain.com/fault-domains/
* _sink_: https://martinfowler.com/architecture/ https://engineering.videoblocks.com/web-architecture-101-a3224e126947

## baked data

* _baked data_: data embedded as static asset https://simonwillison.net/2020/Dec/13/datasette-io/ https://news.ycombinator.com/item?id=28015980 https://postlight.com/insights/big-data-small-effort
* bc full stack SQL doesn't work https://news.ycombinator.com/item?id=26822884 https://simonwillison.net/2021/Jul/28/baked-data/
* aka flat data https://news.ycombinator.com/item?id=27197950
* sql.js https://github.com/sql-js/sql.js/ https://selectstarsql.com/frontmatter.html#technicals https://jvns.ca/blog/2019/09/30/notes-on-building-sql-exercises/ https://news.ycombinator.com/item?id=27016630
* query SQLite over HTTP https://github.com/psanford/sqlite3vfshttp
* with pyodide https://news.ycombinator.com/item?id=31261777 https://adtax.paulromer.net/

## event-driven 

* https://news.ycombinator.com/item?id=40723302
* https://encore.dev/blog/event-driven-architecture
* https://news.ycombinator.com/item?id=40619521

## jamstack

* _static site_: content not generated on the fly i.e. no db/server interaction https://wsvincent.com/static-vs-dynamic-a-question-of-layers/
* generators https://github.com/ehouse/kackle https://www.youtube.com/watch?v=ShBD5v6YoNw
* _JAMstack_: static site + APIs
* = dynamism via APIs instead of db https://wsvincent.com/what-is-a-static-site-generator/
* advantages: speed (everything on CDN) security (no db) ++ good for SEO? https://immutablewebapps.org
* 📍 clean up --> https://alexdanco.com/2019/10/26/everything-is-amazing-but-nothing-is-ours/ apparently good for SEO as well Netlify, Gridsome https://redwoodjs.com/ deployment on Zeit, Netlify https://softwareengineeringdaily.com/2020/04/30/jamstack-content-management-with-scott-gallant-jordan-patterson-and-nolan-phillips/ 15:00 https://hacks.mozilla.org/2020/10/mdn-web-docs-evolves-lowdown-on-the-upcoming-new-platform  what it means for backend dev https://www.youtube.com/watch?v=Z2JK7SS82wE https://www.youtube.com/watch?v=grSxHfGoaeg https://scotch.io/@sw-yx/python-the-jamstack

## microservices

> Microservices, while often sold as solving a technical problem, usually actually solve for a human problem in scaling up an organization. There's two technical problems that microservices purport to solve: modularization (separation of concerns, hiding implementation, document interface and all that good stuff) and scalability (being able to increase the amount of compute, memory and IO to the specific modules that need it). The first problem, modules, can be solved at the language level. Modules can do that job, and that's the point of this blog post. The second problem, scalability, is harder to solve at the language level in most languages outside those designed to be run in a distributed environment. But most people need it a lot less than they think. Normally the database is your bottleneck and if you keep your application server stateless, you can just run lots of them; the database can eventually be a bottleneck, but you can scale up databases a lot. The real reason that microservices may make sense is because they keep people honest around module boundaries. They make it much harder to retain access to persistent in-memory state, harder to navigate object graphs to take dependencies on things they shouldn't, harder to create PRs with complex changes on either side of a module boundary without a conversation about designing for change and future proofing. Code ownership by teams is something you need as an organization scales, if only to reduce the amount of context switching that developers need to do if treated as fully fungible; owning a service is more defensible than owning a module, since the team will own release schedules and quality gating. I'm not so positive on every microservice maintaining its own copy of state, potentially with its own separate data store. I think that usually adds more ongoing complexity in synchronization than it saves by isolating schemas. A better rule is for one service to own writes for a table, and other services can only read that table, and maybe even then not all columns or all non-owned tables. Problems with state synchronization are one of the most common failure modes in distributed applications, where queues get backed up, retries of "bad" events cause blockages and so on. https://news.ycombinator.com/item?id=34231020

* https://github.com/micro/micro
* = distributed monolith, modularity https://news.ycombinator.com/item?id=31727453
* need more infra knowhow: 5 devs per service https://pythonspeed.com/articles/dont-need-kubernetes/
* https://world.hey.com/dhh/how-to-recover-from-microservices-ce3803cc
* _service layer_: Java-style abstraction https://www.b-list.org/weblog/2020/mar/16/no-service/
* make it a library instead http://catern.com/services.html
* business organization: https://news.ycombinator.com/item?id=23017388
> What microservices let you do is ship your org chart directly, and also map back from some functionality to an owning team. https://news.ycombinator.com/item?id=26247052
* _push_: if receiving svc goes down push svc has to stop
* _pull_: if push svc goes down receiving svc doesn't know (maybe the push svc just doesn't have any messages to push?) set batch size in polling svc (so it pulls when there's, say, 50 msgs vs. on each new msg)
* _sink_: https://www.feval.ca/posts/microservices/ Herman course https://www.zachvalenta.com/notes/2018-feval-microservices.html https://www.vinaysahni.com/best-practices-for-building-a-microservice-architecture https://www.dwmkerr.com/the-death-of-microservice-madness-in-2018/ https://nickjanetakis.com/blog/microservices-are-something-you-grow-into-not-begin-with https://nickjanetakis.com/blog/microservices-are-something-you-grow-into-not-begin-with https://robertnorthard.com/devops-days-well-architected-monoliths-are-okay/ https://segment.com/blog/goodbye-microservices/ https://blogs.dxc.technology/2018/05/08/everything-old-is-new-again-microservices/ https://changelog.com/podcast/312 https://news.ycombinator.com/item?id=22193383
* _benefits_: devs (specialization, experimentation) ergonomics (easier to grok)
* _drawbacks_: no joins (favor document db) outside single process (slower, flaky network) devs (easy code, complex infrastructure) hard to integration test https://aadrake.com/posts/2017-05-20-enough-with-the-microservices.html https://thoughtbot.com/blog/services-are-not-a-silver-bullet
* _communcation_: mq, pub-sub, RPC/REST https://testdriven.io/courses/microservices-with-docker-flask-and-react/part-one-microservices/

## monolith

---

* _bikeshedding_: aka yak shaving https://jsonapi.org/ http://bikeshed.org/ https://drewdevault.com/2020/08/17/Engineers-solve-problems.html
> Some applications where you would consider ditching Django to shave off some latency are: a stock trading marketplace; an global online advertisement serving network; a low level infrastructure control API - https://mattsegal.dev/is-django-too-slow.html
> Forget that all these things exist: Microservices, Lambda, API Gateway, Containers, Kubernetes, Docker. Anything whose main value proposition is about “ability to scale” will likely trade off your "ability to be agile & survive". That’s rarely a good trade off. Start with a t3.nano EC2 instance, and do all your testing & staging on it. It only costs $3.80/mo. Then before you launch, use something bigger for prod, maybe an m5.large (2 vCPU & 8 GB mem). It’s $70/mo and can easily serve 1 million page views per day. - https://twitter.com/dvassallo/status/1154516910265884672
> don't waste time on problems you don't have yet 📙 Getting Real [42]
> The bigger problem isn't scaling, it's getting to the point where you have to scale. 📙 Getting Real [42]
> It is well-known that the majority of the cost of software is not in its initial development, but in its ongoing maintenance [Kleppmann 24] Vinsel, Innovation Delusion
> Scaling for many web applications is typically bottlenecked by the database, not the web workers. - https://pythonspeed.com/articles/dont-need-kubernetes/ https://stribny.name/blog/2020/07/scaling-relational-sql-databases
> Build a monolith with copious amounts of telemetry. Use a RDBMS. Use a CDN. Let your telemetry guide you on how to scale, cache, or split your workloads. Don't hire people who want to boil the ocean. https://news.ycombinator.com/item?id=25037628
* just use one big db https://news.ycombinator.com/item?id=31084147
* _vertical scaling_: get faster drives for db
> I am always puzzled about this "autoscale" thing on a cloud. If your task can be represented as something like calculate sum of some ginormous array then sure. Split array in parts and launch thousand instances each working on it's own slice and then combine. In way more common situation you have a service hitting database and doing something with it. Sure you can spin a thousand instances of said service. But they will all be hitting the same database. - https://news.ycombinator.com/item?id=21741870
* _horizontal scaling_: shard https://www.youtube.com/watch?v=7v-wrJjcg4k until recently you waited as long as you could on this 📙 Kleppmann 1.18
> horizontal-scaling is often based on the partitioning of the data i.e. each node contains only part of the data, in vertical-scaling the data resides on a single node and scaling is done through multi-core i.e. spreading the load between the CPU and RAM resources of that machine. With horizontal-scaling it is often easier to scale dynamically by adding more machines into the existing pool - Vertical-scaling is often limited to the capacity of a single machine, scaling beyond that capacity often involves downtime and comes with an upper limit. - https://stackoverflow.com/a/11715598/6813490

KISS
* aka transitional architecture https://www.thoughtworks.com/radar/techniques?blipid=202203071
> But the cultural tides are strong. Building a company on Django in 2020 seems like the equivalent of driving a PT Cruiser and blasting Faith Hill’s “Breathe” on a CD while your friends are listening to The Weeknd in their Teslas. Swimming against this current isn’t easy, and not in a trendy contrarian way. https://macwright.com/2020/05/10/spa-fatigue.html
* https://martinfowler.com/bliki/Yagni.html https://www.jefftk.com/p/designing-low-upkeep-software
* https://thorstenball.com/blog/2020/09/15/the-context-in-which-we-build-software/
* https://news.ycombinator.com/item?id=26071906
* boring tech has well-understood failure modes https://news.ycombinator.com/item?id=23444594 https://sourcehut.org/blog/2020-06-10-how-graphql-will-shape-the-alpha/
* https://sourcehut.org/blog/2020-06-10-how-graphql-will-shape-the-alpha/
* https://josephg.com/blog/databases-have-failed-the-web/
* https://twitter.com/b0rk/status/1229860328139296768
* https://wizardzines.com/about/
* https://blog.cerebralab.com/Imaginary_Problems_Are_the_Root_of_Bad_Software https://blog.cerebralab.com/Stop_future_proofing_software
* https://blog.cerebralab.com/Bimodal_programming_%E2%80%93_why_design_patterns_fail
* Hickey simple made easy https://news.ycombinator.com/item?id=38433358 https://www.youtube.com/watch?v=LKtk3HCgTa8 data is not easy https://grishaev.me/en/ddd-lie
* https://www.benkuhn.net/progessays/
* one dev's edge cases are another's entire project 📙 Kleppmann 491
* listen to Knuth -> fast code matters less than you think https://www.youtube.com/watch?v=PhUb7y9WZGs
> We should forget about small efficiencies, say about 97% of the time; premature optimization is the root of all evil. - Donald Knuth
* write code that's easy to throw away
> Write code to be changed and/or deleted. This comes from someone who's worked in startups for the past 5 years. We often overestimate how long code =is supposed to live. We as programmers often exaggerate with our DRY and stuff, we do not want to repeat ourselves, we want to find another abstraction...we want to find some general that can help us abstract stuff away. My piece of advice is that, step back and consider for a moment that this code is not going to stay in, so maybe only try and find the abstraction layer once you really sure that this is how it's going to be. - Thorsten Ball https://developeronfire.com/podcast/episode-373-thorsten-ball-interpreters-compilers-and-writing
> To be attractive to hackers, a language must be good for writing the kinds of programs they want to write. And that means, perhaps surprisingly, that it has to be good for writing throwaway programs. - http://paulgraham.com/popular.html
* don't cargo cult 'best practices'
> Sophisticated design principles can make your code faster, more flexible, more modular, and all of the other positive adjectives that people use to describe high-quality software. But they also make it more complex. `AbstractSyntaxRenderers` and `DoubleBackflipDatabaseTransmogrophiers` do make some programs clearer and easier to understand, especially large ones. But they can also be the equivalent of using a metrics-oriented, fully agile, stakeholder-prioritized development flow for working on a jigsaw puzzle with your dad. Sure you’re following best practices, but you probably didn’t need to, and now your dad thinks you’re a Scientologist. - https://robertheaton.com/2018/12/02/programming-project-5-snake/
* wait for shared concerns to emerge -> repeat yourself until you find the right abstraction https://programmingisterrible.com/post/176657481103/repeat-yourself-do-more-than-one-thing-and
> There seemed to be a tendency to extract tiny packages first instead of waiting for a shared concern to emerge from the code and only then extracting a package. https://commandercoriander.net/blog/2017/12/31/writing-go/
> The problem with always using an abstraction is that you’re preemptively guessing which parts of the codebase need to change together. “Don’t Repeat Yourself” will lead to a rigid, tightly coupled mess of code. Repeating yourself is the best way to discover which abstractions, if any, you actually need.
> Beware of arguments related to programming speed. All things being equal, faster is better. But all things are never equal. Do you need the kind of speed that lets you get a website up and running quickly? Or the kind that allows you to rotate a few thousand polygons in 3D in real time? Do you need to convert 10,000 PDFs into text per hour? Or 10 million PDFs into text once? These are different problems. - Ford what is code?

## no code

* _retool_: https://retool.com/ https://www.youtube.com/watch?v=4xuBT3BbsYU https://www.youtube.com/watch?v=ChTGbmR2NeM
* wrap and connect APIs https://softwareengineeringdaily.com/2019/12/19/no-code-with-shawn-wang/ aka workflow automation https://github.com/n8n-io/n8n https://news.ycombinator.com/item?id=24648960
* _automatisch_: Zapier alternative https://github.com/automatisch/automatisch https://tedium.co/2023/03/04/self-hosted-saas-app-alternatives/
* _Zapier_ https://softwareengineeringdaily.com/2020/02/27/makerpad-low-code-tools-with-ben-tossell/ https://softwareengineeringdaily.com/2020/02/26/parabola-no-code-data-workflows-with-alex-yaseen/ https://github.com/mkjt2/lockbox
* Honey Comb https://news.ycombinator.com/item?id=23633110 https://www.alexhudson.com/2020/01/13/the-no-code-delusion/ https://www.makerpad.co/ WebFlow https://news.ycombinator.com/item?id=27421408
* https://news.ycombinator.com/item?id=28984955

## serverless

* types: FaaS (Lambda) cloud SQL (BigQuery) ITTT (Zapier) msg (Twilio)
* start: warm (run code) cold (download code, start container, bootstrap runtime, run code) https://www.youtube.com/watch?v=NhDYbskXRgc [1:12:30]
* costs more and runs slower https://einaregilsson.com/serverless-15-percent-slower-and-eight-times-more-expensive/
* saves on devops labor costs https://news.ycombinator.com/item?id=21046547
* bad for local dev https://twitter.com/dvassallo/status/1154516910265884672 
* testing https://buddy.works/tutorials/integration-testing-for-aws-lambda-in-go-with-docker-compose

# 🌌 DISTRIBUTED

🗄
* `big-data.md` replicate/partition
* `infra.md` queues
📚
* Arpaci ch. 48-50
* Galvin dinosaur chapter 17
* Jeffrey distributed
* Kleppmann data intensive
* Petrov ch. 8-14
* Takada fun/profit http://book.mixu.net/distsys/index.html

BLOCKCHAIN https://a16zcrypto.com/
* design https://unwttng.com/what-is-a-blockchain https://a16z.com/2018/02/10/crypto-readings-resources/ https://www.manning.com/books/grokking-bitcoin
* https://cdixon.org/2018/02/18/why-decentralization-matters
> Blockchains are special computers that anyone can access but no one owns. https://twitter.com/cdixon/status/1442201642338643969
* BYO https://news.ycombinator.com/item?id=27594943 https://norswap.com/blockchain-how/ https://hackernoon.com/learn-blockchains-by-building-one-117428612f46 
* history: https://danromero.org/crypto-reading/
* design: size of chain makes fraud difficult bc would have tamper with block, then re-write proceeding blocks on all nodes
* _blockchain_: db distributed over p2p network w/ each node holding entire db https://danielmiessler.com/study/blockchain/
* _smart contract_: app using blockchain
* _oracle_: data ingestion onto chain

---

* _distributed system_: no shared memory, no shared clock https://news.ycombinator.com/item?id=26089683
* needs coordination across network/cores 📙 Jeffrey distributed [4]
* hard https://en.wikipedia.org/wiki/Fallacies_of_distributed_computing
> You need whole new categories of instrumentation and logging to getting understanding that isn’t quite as good as what you’d get from the logs of a monolithic application. https://pythonspeed.com/articles/dont-need-kubernetes/
* why: availability, durability, flexibility, locality https://news.ycombinator.com/item?id=29006223
> What happens when that database fails? Are you OK losing some data, or do you want the data to be synchronously replicated off the machine and be available somewhere else after failure? Distribution isn't only about scale, it's also about availability.
> What happens when that database loses some data? Do you want an up-to-the second backup, or point-in-time recovery? Or are you OK restoring last night's backup? Distribution isn't only about scale, it's also about durability.
> What happens when you need to run an expensive business process ad-hoc? Do you want it to be easy to scale out reads, or to export that data to an analytics system? Or are you OK building something else to handle that case? Distribution isn't only about scale, it's also about flexibility.
> What happens when you want to serve customers in one market, and make sure that their data stays local for regulatory compliance reasons or latency? Are you OK with having separate databases? Distribution isn't only about scale, it's also about locality.
* mesh, service weaver https://serviceweaver.dev/blog/quick_intro.html

https://drewdevault.com/2020/09/20/The-potential-of-federation.html
* _centralized_: you own all the servers
* _peer to peer (p2p)_: you only own your serverr
* _federation_: servers work together but not p2p https://lwn.net/Articles/687294/ https://github.com/mastodon/mastodon

za
* _Jepsen analysis_: standard safety in distributed/transactional systems https://news.ycombinator.com/item?id=8385970 https://news.ycombinator.com/item?id=26645654 https://www.micahlerner.com/2021/06/12/foundationdb-a-distributed-unbundled-transactional-key-value-store.html
* _GFS (Google File System)_: https://www.micahlerner.com/2020/03/22/understanding-googles-file-system.html

## CAP theorem

---

Petrov ch. 11

🗄 `algos.md` probabilistic data structures

* https://www.youtube.com/watch?v=_RbsFXWRZ10 https://softwareengineeringdaily.com/2023/07/25/cap-theorem/
* _CAP theorem_: tradeoffs if network partition
* _consistency_: ACID
* eventually consistent https://cloudonaut.io/my-mental-model-of-aws/
* _availability_: res for req
* _partition tolerance_: works offline 📙 Conery 336
* C: refuse to incoming reads/writes
* A, P: (db remains available but other cluster members becoming inconsistent)
* choose consistency 📙 `evans-linux.pdf` 2

## consensus

📙 Kleppmann ch. 8-9

* https://sre.google/sre-book/table-of-contents/ chapter 23
* _leader election_: Raft algorithm https://www.micahlerner.com/2020/05/08/understanding-raft-consensus.html Paxos https://news.ycombinator.com/item?id=24906225

Raft https://raft.github.io/
* start here https://pyvideo.org/pygotham-2017/an-introduction-to-the-raft-distributed-consensus-algorithm.html https://news.ycombinator.com/item?id=31416812 https://notes.eatonphil.com/distributed-postgres.html https://news.ycombinator.com/item?id=35246228
* BYO https://eli.thegreenplace.net/2020/implementing-raft-part-1-elections/ https://github.com/streed/simpleRaft https://github.com/bbbilibili/raft-1----python https://github.com/erewok/raft-py https://github.com/xwhan/Raft-python
* https://www.micahlerner.com/2020/05/08/understanding-raft-consensus.html https://www.micahlerner.com/2020/05/09/understanding-raft-consensus-part-2.html
* https://www.confluent.io/blog/why-replace-zookeeper-with-kafka-raft-the-log-of-all-logs/

---

CONFLICT RESOLUTION
* _operational transform_: funnel changes through central server, this is what Google Docs uses, a bunch of algorithms have been applied and found to fail
* _CRDT_: maintain each user's data in format that clients can resolve themselves https://en.wikipedia.org/wiki/Conflict-free_replicated_data_type
> CRDT is a collection of data types that all share a very nice property: they can always be merged. It’s not always the perfect merge, and not everything can be made into a CRDT, but IF you can put your data into a CRDT, you can be sure: all merges will go without conflicts. https://tonsky.me/blog/crdt-filesync/
* local-first https://tonsky.me/blog/crdt-filesync/
> Prefers keeping your data local but it still goes to the internet occasionally to sync with other users, fetch data, back up, etc.  If it doesn't go to the internet at all, it's just local software. If it doesn't work offline with data it already has, then it's just normal cloud software. You all know the type - sorry, Dave, I can't play the song I just downloaded because your internet disappeared for one second
* syncing without CRDT https://tonsky.me/blog/crdt-filesync/
> But what happens if you change the state on two machines? Well, you get a conflict file:
```sh
foo.md
foo-conflict-20240705-0981234.md
```
* syncing with CRDT https://tonsky.me/blog/crdt-filesync/
> We can solve conflicts by opening both files, merging states, and saving back to the original file.
* BYO https://github.com/tonsky/crdt-filesync https://automerge.org/

more crdt
* https://softwareengineeringdaily.com/2017/12/08/decentralized-objects-with-martin-kleppman/ https://www.inkandswitch.com/local-first.html https://github.com/xi-editor/xi-editor/issues/1187#issuecomment-491473599 https://news.ycombinator.com/item?id=37764581 https://martin.Kleppmann.com/2020/07/06/crdt-hard-parts-hydra.html https://caolan.uk/articles/inside-a-collaborative-text-editor/ vs OT (operational transformations) https://news.ycombinator.com/item?id=24176455 https://news.ycombinator.com/item?id=24617542 https://news.ycombinator.com/item?id=24790170 https://www.youtube.com/watch?v=Paau_t0aZKw https://automerge.org/ https://vlcn.io/blog/gentle-intro-to-crdts.html https://github.com/alangibson/awesome-crdt

* https://lethain.com/distributed-systems-vocabulary/
* _distributed locks_: https://hazelcast.com/blog/long-live-distributed-locks/
* _Lamport timestamp_: https://towardsdatascience.com/understanding-lamport-timestamps-with-pythons-multiprocessing-library-12a6427881c6
* _Lamport clock_: https://martinfowler.com/articles/patterns-of-distributed-systems/lamport-clock.html
* _Byzantine generals problem_: achieve consensus when some actors are unreliable https://en.wikipedia.org/wiki/Byzantine_fault
* _Reed-Solomon_: way to protect messages against damage or partial arrival https://news.ycombinator.com/item?id=27491219
* _semaphore_: synchronization primative, 类似 mutex/lock https://greenteapress.com/wp/semaphores/ https://danluu.com/programming-books/ https://en.wikipedia.org/wiki/Semaphore_(programming) https://sqlfordevs.com/transaction-locking-prevent-race-condition
* on having more than one primary 📙 Bradshaw [243]
* locks for task, Shedlock https://www.thoughtworks.com/radar/languages-and-frameworks?blipid=202203061
* https://robertovitillo.com/what-every-developer-should-know-about-database-consistency/ https://news.ycombinator.com/item?id=28425379
* _eventual consistency_: when db gets write operation, responds w/ ack and then does write when it gets time, meaning one node could receive write, ack, write it, and then need time to propagate write to other nodes, which means during that time the system would be in a state of inconsistency; benefit is that distributed system means you can put lots of processing power behind your db so the walltime of inconsistent states should be very short; aka 'AP system' 📙 Conery 337-8
> https://www.youtube.com/watch?v=rpqsSkTIdAw
> eventually consistent = eventually corrupt https://www.youtube.com/watch?v=h8cyPIEfxQY 7:45
* https://nchammas.com/writing/database-access-patterns
* _new SQL_: relational semantics + non-relational scaling
* more resistant to CAP theory resistant SQL i.e. seems to shard more finely so that in network partition some very high % of cluster can remain available i.e. trade-off still there just minimized to the point that most users won't notice https://www.prisma.io/blog/comparison-of-database-models-1iz9u29nwn37
* dbms: Cockroach https://www.openmymind.net/Migrating-To-CockroachDB/ Spanner, Rethink https://brandur.org/cloud-databases distributed https://github.com/erikgrinaker/toydb https://github.com/rqlite/rqlite https://github.com/maxpert/marmot

## service discovery

🗄 consensus

---

📍
* https://www.youtube.com/watch?v=S7bsPbJvBzU
* try out Consul locally https://learn.hashicorp.com/tutorials/consul/get-started-install?in=consul/getting-started

* _service discovery_: registry of available services https://www.youtube.com/watch?v=Vv4HpLfqAz4 9:45
* aka configuration store https://github.com/zalando/patroni
* e.g. Zookeeper, etcd, Consul https://stackoverflow.com/a/48652680
* vs. static config of available services https://www.youtube.com/watch?v=Vv4HpLfqAz4 10:00
* like DNS https://www.youtube.com/watch?v=Vv4HpLfqAz4 1:35

ZOOKEEPER https://www.youtube.com/watch?v=Vv4HpLfqAz4
* high level: distributed KV store [8:35]
* impl: tree/hierarchical data model 类似 file system [8:50]
* features: service discovery + leader election https://www.youtube.com/watch?v=AS5a91DOmks 0:45
* used by: Kafka (previously) FoundationDB (itself a distributed KV store) https://www.micahlerner.com/2021/06/12/foundationdb-a-distributed-unbundled-transactional-key-value-store.html
* _znode_: node in tree [9:20]
* _node_: server in Zookeeper cluster [9:30]

## transactions

🗄 `system.md`
📙
* Bradshaw ch. 8
* Kleppmann ch. 7

📍 rf re: 'dbms taxnomy'

* _serializability_: ordered transactions https://www.micahlerner.com/2021/06/12/foundationdb-a-distributed-unbundled-transactional-key-value-store.html

---

https://hakibenita.com/django-nested-transaction
* https://jepsen.io/analyses/mysql-8.0.34
https://sqlfordevs.com/transaction-locking-prevent-race-condition

transactions & isolation levels 📙 Beaulieu 12
* https://retool.com/blog/isolation-levels-and-locking-in-relational-databases/ https://jahfer.com/posts/innodb-locks/ https://www.postgresql.org/docs/9.5/transaction-iso.html
* _transaction_: unit of work https://unixsheikh.com/articles/sqlite-the-only-database-you-will-ever-need-in-most-cases.html https://sqlite.org/transactional.html https://news.ycombinator.com/item?id=33934694
* _commit_: save change; happens in two phases http://dbmsmusings.blogspot.com/2019/01/its-time-to-move-on-from-two-phase.html
* _serializable_: transactions only execute concurrently if end result is same as them executing sequentially
* repeatable read: 
* DDL changes can be transactional as well https://news.ycombinator.com/item?id=28077797

ACID 📙 Kleppmann 7, section 2 🗄 `django.md` design https://lethain.com/distributed-systems-vocabulary/
* https://www.youtube.com/watch?v=yaQ5YMWkxq4
* _atomic_: transaction succeeds/fails as an entire unit https://brandur.org/postgres-atomicity
* NoSQL kinda does http://aosabook.org/en/nosql.html
> Most NoSQL systems pick performance over full ACID guarantees, but do provide guarantees at the key level: two operations on the same key will be serialized, avoiding serious corruption to key-value pairs. For many applications, this decision will not pose noticeable correctness issues, and will allow quick operations to execute with more regularity. It does, however, leave more considerations for application design and correctness in the hands of the developer.
* _consistent_: transaction changes db from one valid state to another 
* eventual consistency 📝 Vogel https://dl.acm.org/doi/10.1145/1435417.1435432
* semantics https://lethain.com/distributed-systems-vocabulary/
* _isolated_: protection from dirty read
* no transaction affects another happening at the same time 📙 Conery 335
* _durable_: successful transaction will survive hardware fault e.g. server restart 📙 Kleppmann 226
* nothing can change transaction except another update 📙 Conery 335
* uses `fsync` http://aosabook.org/en/nosql.html https://sirupsen.com/napkin/problem-10-mysql-transactions-per-second

locking
* _lock_: db disallows other processes to access object (table, row, etc.)
* 'held' by transaction https://jahfer.com/posts/innodb-locks/
* handle at app level by throwing error or retry https://lincolnloop.com/blog/distributed-locking-django/
* _latch_: lightweight lock 📙 Kleppmann 82
* _dirty read_: read uncommitted data
* e.g. transaction 1 updates a row, transaction 2 reads the updated row before transaction 1 commits the update, transaction 1 rolls back the change, transaction 2 will have read data that is considered never to have existed https://retool.com/blog/whats-an-acid-compliant-database/

# 🟨 ZA

---

SEMANTICS 🗄 distributed/semantics
* _architecture_: the stuff that's hard to change
* will change with each order of magnitude i.e. from 1.5k users to 10k 📙 Kleppmann [17,22]
* _node_: process https://leanpub.com/systemdesignmanual/read_sample
* _service_: 1/n nodes providing API https://leanpub.com/systemdesignmanual/read_sample
* _elastic_: scales automatically with load 📙 Kleppmann [17]

SEARCH
* _Algolia_: record (JSON obj) field (attr on obj) clients https://github.com/algolia/algoliasearch-client-javascript https://github.com/algolia/algoliasearch-client-python
* _Elasticsearch_: use in Postgres https://github.com/zombodb/zombodb alternative https://github.com/valeriansaliou/sonic https://github.com/paradedb/paradedb
* _Lucene_: framework https://stackoverflow.com/questions/15704644/difference-between-solr-and-lucene
* _Meilisearch_: https://github.com/meilisearch/MeiliSearch https://news.ycombinator.com/item?id=22685831 https://github.com/valeriansaliou/sonic https://softwareengineeringdaily.com/2019/03/20/elasticsearch-at-scale-with-volkan-yazici/ https://github.com/typesense/typesense https://news.ycombinator.com/item?id=25414389 https://tech.marksblogg.com/meilisearch-full-text-search.html https://tech.marksblogg.com/meilisearch-full-text-search.html
* _RediSearch_: built on Redis https://oss.redislabs.com/redisearch/
* _Redka_: Redis fork using SQLite https://github.com/nalgeon/redka
* _Solr_: built on Lucene https://blog.codepen.io/2016/05/24/091-solr/
* _Typesense_: https://github.com/typesense/typesense https://xkcd-search.typesense.org/ https://www.thoughtworks.com/radar/tools?blipid=202203031
* _whoosh_: project is dead https://github.com/gyllstromk/Flask-WhooshAlchemy/issues/69 https://stackoverflow.com/a/53338666/6813490 
* _Zinc_: https://github.com/zinclabs/zinc

## caching

📙 Christian chapter 4
🗄
* proxy
* `http.md` caching

semantics
* _cache_: tmp storage for read; e.g. browser (SQLite) network (CDN) db (connection pool); can cache to either memory or disk https://danielmiessler.com/blog/nginx-caching-tempfs/
* _buffer_: tmp storage for write
> Python's standard out is buffered (meaning that it collects some of the data "written" to standard out before it writes it to the terminal). Calling sys.stdout.flush() forces it to "flush" the buffer, meaning that it will write everything in the buffer to the terminal, even if normally it would wait before doing so. https://stackoverflow.com/questions/10019456/usage-of-sys-stdout-flush-method
* flush buffer https://stackoverflow.com/questions/3167494/how-often-does-python-flush-to-a-file https://stackoverflow.com/questions/29712445/what-is-the-use-of-buffering-in-pythons-built-in-open-function

* e.g. Python writerow
* _flush_: write buffer to disk https://stackoverflow.com/a/15042890
* _memoization_: cache at function level https://stackoverflow.com/a/6469470 https://news.ycombinator.com/item?id=31434078
* _cold_: infrequently used data
* _hot_: frequently used data
* _cache hit_: can pull from cache
> A cache hit is hopefully much more than twice as fast as a cache miss. https://calpaterson.com/ttl-hell.html
* _cache miss_: have to go to db
> It's important never to require a cache hit - even as a soft requirement. Evictions can happen at inconvenient times - such as when some other part of the system is under load - and there mustn't be any negative consequences to a cache miss. https://calpaterson.com/ttl-hell.html

eviction, expiry
* _eviction_: rm item based on usage e.g. LRU
* _expiration_: rm item based on TTL https://calpaterson.com/ttl-hell.html
> Data can be evicted before it has expired. And it often will be: most caches don't consider the TTL when looking for stuff to evict.
> Caching by TTL gives up correctness to gain speed.
* _LFU_: 
* random: 
* _LRU_: ensures cache full/hot as possible; used by application caches https://calpaterson.com/ttl-hell.html
```python
# There's nothing wrong with the above code but it only allows for strategy #1: never invalidate https://calpaterson.com/ttl-hell.html
from functools import lru_cache
@lru_cache(maxsize=1000)
def get_slow_thing_v1(thing_id):
    thing = get_slow_thing_from_a_database_layer(thing_id)
    return thing
```
* _update-on-write_: update cache item on db write
> Sometimes you want to cache something that will change. For example, your application's User object: username, email address, postal address, etc. This data is bound to change over time but is also accessed extremely frequently, often on every request or as part of every operation. The best approach here is to update the cache whenever you update the data in your persistent store.

misc
* _cache stampede_: user req for item not in cache, code begins to generate, during generation other reqs for same item, code begins n generations, server falls over; avoid by putting flag in cache to say "hey, I'm working on creating this item"
* _thrashing_: when computation continuously interrupted by context switch of cache items from one program to another resulting in no computation being done
* _namespace_: add timestamp key (210526) to item key (user-bob) https://calpaterson.com/ttl-hell.html

ideas https://calpaterson.com/ttl-hell.html
> Using a cache often changes the implicit complexity class of the system - downwards, and towards constant time.
> There's a snobbery about application level caches. It's more respectable to rewrite the program in a "systems programming language" (read: fast, compiled, for the serious) than to apply Memcache liberally to your PHP app (read: a "band-aid", apache2, used only by jokers).
> One particularly naughty thing to do is to store web sessions only in the cache. A cache miss then becomes an involuntary logout for the hapless user who has done nothing wrong and transgressed no one. Instead, use strategy #2 above and store the web-sessions in your database, using your cache just as a speedup.
> One tip: it's best to start by looking to invalidate. To paraphrase someone: "ask not of what you can cache - ask of what you can invalidate". If you can't invalidate something reliably, it's unlikely that you can cache it in the first place.

---

* https://softwareengineeringdaily.com/2023/08/08/database-caching-with-ben-hagan/
* TTL https://news.ycombinator.com/item?id=26620730 https://calpaterson.com/ttl-hell.html
* _cache invalidation_: https://news.ycombinator.com/item?id=26686770 https://blog.cerebralab.com/The_second_hardest_thing_in_programming_-_Part_1
* Cloudflare do image compression per browser (e.g. webp for Chrome) https://runninginproduction.com/podcast/4-real-python-is-one-of-the-largest-python-learning-platforms-around#44:00
https://healeycodes.com/webdev/python/beginners/tutorial/2019/07/07/introduction-to-caching-with-python.html

in Python
* BYO https://dbader.org/blog/python-memoization use a decorator https://github.com/realpython/python-guide/blob/1d5905d5d7e25ebf11cda50d3d93ac636c87a993/docs/writing/structure.rst#decorators
* built-in LRU cache https://datawhatnow.com/things-you-are-probably-not-using-in-python-3-but-should/
* https://adamj.eu/tech/2021/01/21/simple-in-memory-caching-of-django-models-with-cachetools/

in general

> A good example of a piece of functionality that is better handled with decoration is memoization or caching: you want to store the results of an expensive function in a table and use them directly instead of recomputing them when they have already been computed. This is clearly not part of the function logic. [Hitchhiker's Guide 3.1.6]

* https://www.openmymind.net/Caching-Your-Worst-Best-Friend/
* https://bhavaniravi.com/blog/caching-in-python 
* https://ieftimov.com/post/when-why-least-frequently-used-cache-implementation-golang/ 
* http://danluu.com/2choices-eviction/
* https://www.digitalocean.com/community/tutorials/web-caching-basics-terminology-http-headers-and-caching-strategies

## diagrams

🗄
* `aesthetics.md` design
* `math.md` graphs

TYPES
* _concept map_: https://cmap.ihmc.us/docs/learn.php
* _DAG_: https://arthursonzogni.com/Diagon/#GraphDAG
* _ERD_: syntax https://eli.thegreenplace.net/2019/to-orm-or-not-to-orm/ 📙 Karwin [7] 🗄 `sql.md` utils
* _flow_: https://news.ycombinator.com/item?id=26303784
* _infrastructure_: https://github.com/mingrammer/diagrams 
* _mind map_: https://github.com/nadrad/h-m-m https://markmap.js.org/ https://news.ycombinator.com/item?id=24132631 https://news.ycombinator.com/item?id=27614912 https://strlen.com/treesheets/ https://news.ycombinator.com/item?id=34184993 https://blog.dornea.nu/2015/09/17/organizing-and-visualizing-knowledge/ https://www.dendron.so/
* _state_: https://github.com/statecharts/statecharts.github.io/issues/44 https://en.wikipedia.org/wiki/State_diagram
* _treemap_: https://github.com/niyue/skillmap https://github.com/nikolaydubina/go-cover-treemap
* _sequence_: msg passing https://sequencediagram.org https://gist.github.com/zachvalenta/2aeac1f945c5848c79087b2481cb187a https://arthursonzogni.com/Diagon/#Sequence
* https://jessems.com/posts/2023-07-22-the-unreasonable-effectiveness-of-sequence-diagrams-in-mermaidjs
* _UML_: aka class diagram https://www.amazon.com/UML-Distilled-Standard-Modeling-Language/dp/0321193687
* alternative syntax 📙 Evans domain-driven [42]
* can be used for ERD in Mongo https://stackoverflow.com/q/11323841 https://stackoverflow.com/q/6010408

| provider   | types             |   notes                                                                         |
|------------|-------------------|---------------------------------------------------------------------------------|
| D2         | ERD, sequence     | https://play.d2lang.com/                                                        |
| DrawSQL    | ERD               | https://drawsql.app/me-195/diagrams/testing123                                  |

PROVIDERS 🔍 https://xosh.org/text-to-diagram/
* ascii to SVG https://github.com/ivanceras/svgbob http://asciiflow.com/
* _DrawSQL_: ERD
* _Excalidraw_: https://excalidraw.com/ https://gist.github.com/zachvalenta/f4c2226b991b69d129fe7d1d40119f43
* _GraphViz_: https://sketchviz.com/graphviz-examples https://github.com/BurntSushi/erd
* _Mermaid_: editor https://mermaid.live/ no current Hombrew version https://github.com/mermaid-js/mermaid-cli https://github.com/mermaid-js/mermaid-cli/issues/25
* mermaid https://news.ycombinator.com/item?id=34906378
* _Monodraw_: https://monodraw.helftone.com/
* _PlantUML_: UML `.puml`

## proxy

🗄
* `flask.md` context
* `infra.md` servers

load balancing https://sre.google/sre-book/table-of-contents/

SERVERS
* req/res: OS takes req on port, hands req to web server, web server hands req to app server, app server hands req to application, res flow back up
* servers useful in Python bc GIL only allows one thread to execute at a time so server does pools other connections 📙 Butcher practice 1.3.3
* why use a server? in Python's case bc 
* _machine_: hw (or vm) https://sre.google/sre-book/production-environment/
* _server_: machine w/ server sw or sw itself https://sre.google/sre-book/production-environment/
* _web server_: deal w/ HTTP, handle static content and rate limiting https://www.quora.com/What-are-the-differences-between-nginx-and-gunicorn
* port 80
* BYO https://ruslanspivak.com/lsbaws-part1/
* _app server_: translate HTTP into obj for web framework
* can also be pressed into service as combo app/web server https://stackoverflow.com/a/38982989 https://www.nginx.com/resources/glossary/application-server-vs-web-server/
* port 8080

CONNECTIONS
* _threads_: single (one thread per connection; WSGI, PHP) multi (📍 http://aosabook.org/en/nginx.html https://uwsgi-docs.readthedocs.io/en/latest/WSGIquickstart.html#adding-concurrency-and-monitoring)
* _idle_: different languages require diff amount of memory e.g. Golang allocates buffer in preparation for data to be read (whereas C++ does not) https://blog.phusion.nl/2018/09/18/migrating-passenger-from-cxx-to-go/
* _multiple_: connections from many clients to single server
* _parallel_: multiple connections from single client to a server; HTTP spec recommends max of 2; workaround is multiple servers deal with different resources
* _persistent_: Keep-Alive, WebSocket
* _pipeline_: send a bunch of requests before waiting for response

TYPES
* _proxy_: layer between requester and responder
* _reverse proxy_: closer to servers; less of a need given a cloud environment where a load balancer is already built-in https://pythonspeed.com/articles/gunicorn-in-docker/ https://testdriven.io/blog/django-docker-traefik/ https://www.artur-rodrigues.com/tech/2023/03/12/reverse-proxy-with-dynamic-backend-selection.html
* _forward proxy_: closer to users; way for users to access resources outside network https://www.linuxbabe.com/it-knowledge/differences-between-forward-proxy-and-reverse-proxy https://github.com/mkjt2/lockbox
* _sidecar proxy_: https://caddyserver.com/docs/

CDN
> Caching reverse proxies that you self-host, like Varnish and Apache Traffic Server, can use non-standard PUSH and PURGE verbs that let you explicitly control the cache contents. If you can invalidate explicitly you can use strategies #2 and #3 [update-on-write]. If you have the file on hand, why not also populate your reverse proxy's cache? The nice thing overall about caching at the HTTP level is that it takes work off the applications server's plate. https://calpaterson.com/ttl-hell.html
* BYO https://github.com/leandromoreira/cdn-up-and-running
* https://jvns.ca/blog/2016/04/29/cdns-arent-just-for-caching/
* https://css-tricks.com/adding-a-cdn-to-your-website/
* Google/Facebook CDNs are blocked in China https://www.freecodecamp.org/news/devblog-launch-your-developer-blog-own-domain/
* https://www.youtube.com/watch?v=6DXEPcXKQNY
* _sink_: https://arp242.net/cdn.html https://css-tricks.com/adding-a-cdn-to-your-website/ http://highscalability.com/blog/2011/2/28/a-practical-guide-to-varnish-why-varnish-matters.html Whitenoise vs. nginx https://blog.doismellburning.co.uk/django-an-unofficial-opinionated-faq/ https://pasztor.at/blog/building-your-own-cdn
* BYO https://dev.to/megajakob/how-to-build-your-own-cdn-io1 https://debugged.it/blog/building-your-own-cdn/

---

* https://github.com/apernet/hysteria
* when things go wrong on Cloudflare https://news.ycombinator.com/item?id=30054739
📍 https://www.youtube.com/watch?v=-W9F__D3oY4
* _OpenResty_: Nginx + script some more logic in with Lua https://www.dataengineeringpodcast.com/linode-object-storage-service-episode-125/ 10:00
* _firewall_: impl rules for server in/egress (e.g. iptables)
* phoning home, open snitch https://news.ycombinator.com/item?id=33506576
* https://softwareengineeringdaily.com/2021/08/10/fly-io-geographic-app-deployment-with-kurt-mackey/
* _sink_: https://serversforhackers.com/t/proxies https://www.maxcdn.com/one/visual-glossary/proxy-caching/ reverse cache https://msdn.microsoft.com/en-us/library/windows/desktop/dd892097%28v=vs.85%29.aspx?f=255&MSPPError=-2147217396 https://blog.envoyproxy.io/introduction-to-modern-network-load-balancing-and-proxying-a57f6ff80236

LOAD BALANCING
* https://news.ycombinator.com/item?id=35588797
* https://www.youtube.com/watch?v=galcDRNd5Ow
* _ALB_: protocols (HTTP, gRPC) algo (round robin based on HTTP headers or session ID) https://aws.amazon.com/compare/the-difference-between-the-difference-between-application-network-and-gateway-load-balancing/
> You should probably use one even if you only have 1 instance. For $16/mo you get automatic TLS cert management, and that alone makes it worth it IMO. You just set it up once & forget about it. An ALB is probably what you’ll need, but NLB is good too. https://x.com/dvassallo/status/1154516910265884672
* _NLB_: protocols (TCP, UDP, TLS) algo (flow hash based on IP address)
* _GLB_: network
* load balancer vs. API gateway vs. ingress controller https://caddyserver.com/docs/
* _HAProxy_: just does load balancing (vs. Nginx, which also serves static assets) https://stackoverflow.com/a/21181066/6813490 conf (port, lb algo, server for forwarding)
* Nginx, Envoy https://dropbox.tech/infrastructure/how-we-migrated-dropbox-from-nginx-to-envoy https://news.ycombinator.com/item?id=32572153
* _algos_: least-busy (based on server pushing <foo> metric?) round-robin (subject to chance i.e. server n could unluckily keep getting the heavier requests) https://www.youtube.com/watch?v=-W9F__D3oY4 @ 18:00
* _hw_: Kemp, Barracuda, F5; run $1-20k bc need to handle GBps of traffic https://news.ycombinator.com/item?id=21095159&utm_term=comment 
* BYO: https://kasvith.github.io/posts/lets-create-a-simple-lb-go/ https://dev.to/bmf_san/implement-a-load-balancer-in-golang-8gj
