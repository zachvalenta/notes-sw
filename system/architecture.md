# ⛩️

## 参考

🗄
* `dbms.md` perf
* `doc.md` viz / system
* `src.md` checklist
* `science.md` complexity
* `telemtry.md` perf
📚
* Buelta python architecture
* Ford fundamentals of software architecture
> they have more books together https://www.amazon.com/Software-Architecture-Trade-Off-Distributed-Architectures/dp/1492086894 https://www.amazon.com/Building-Evolutionary-Architectures-Automated-Governance/dp/1492097543
* Raymond unix programming https://www.arp242.net/the-art-of-unix-programming 🗄️ Kernighan unix a history

## 进步

---

https://bytebytego.com/ https://www.amazon.com/System-Design-Interview-insiders-Second/dp/B08CMF2CQF https://www.amazon.com/System-Design-Interview-Insiders-Guide/dp/1736049119 https://www.youtube.com/watch?v=jPKTo1iGQiE

ROADMAPS
* https://roadmap.sh/system-design
* https://roadmap.sh/software-architect
* https://roadmap.sh/software-design-architecture
* architecture - https://www.cosmicpython.com/book/preface.html
* interviewing - system design - https://github.com/donnemartin/system-design-primer https://github.com/madd86/awesome-system-design https://www.youtube.com/watch?v=VYuToviSx5Q
* https://man.sr.ht/ops/ https://bible-api.com/ https://github.com/seven1m/bible_api https://robertheaton.com/2020/04/06/systems-design-for-advanced-beginners/
* CQRS, service mesh, SOA, scaling (back pressure, throttling) https://roadmap.sh/backend

UNCLE BOB
* https://www.youtube.com/watch?v=qdcamTUcuAQ
* http://cleancoder.com/books
* https://x.com/unclebobmartin
* https://blog.cleancoder.com/
* https://www.amazon.com/Clean-Architecture-Craftsmans-Software-Structure-ebook/dp/B075LRM681
* https://www.amazon.com/Functional-Design-Principles-Patterns-Practices-ebook/dp/B0CGHQKGYG

testing https://www.thediff.co/archive/antithesis-debugging-debugging/ https://antithesis.com/ https://www.thediff.co/archive/offshoring-and-ai-agents/
Kleppmann https://www.davidreis.me/2024/designing-data-intensive-applications
https://www.davidreis.me/2024/what-happens-when-you-make-a-move-in-lichess https://news.ycombinator.com/item?id=41922928
https://drewdevault.com/2021/10/17/Reliability.html
https://drewdevault.com/2020/10/09/Four-principles-of-software-engineering.html
https://drewdevault.com/2020/11/06/Utility-vs-usability.html

* algos https://www.youtube.com/watch?v=xbgzl2maQUU

* https://newsletter.pragmaticengineer.com/p/bluesky-engineering-culture
* https://www.youtube.com/watch?v=HruBoinmPBA
* Discord msgs https://www.youtube.com/watch?v=O3PwuzCvAjI
* Stackoverflow https://www.youtube.com/watch?v=fKc050dvNIE
* https://www.fractionalarchitect.io/books/mastering-strategic-ddd
* https://www.fractionalarchitect.io/books/master-software-architecture
* db per tentant https://news.ycombinator.com/item?id=39004963
* db per user https://news.ycombinator.com/item?id=38171322
* https://maheshba.bitbucket.io/blog/2023/07/12/Design.html
* https://read.engineerscodex.com/p/how-instagram-scaled-to-14-million
* race condition https://portswigger.net/research/smashing-the-state-machine
* state machine, audit https://blog.lawrencejones.dev/state-machines/ https://www.youtube.com/watch?v=YSUxLRlTzZ4
* cellular https://news.ycombinator.com/item?id=37274871
* https://news.ycombinator.com/item?id=36208420
* https://github.com/karanpratapsingh/system-design
* https://davidvujic.blogspot.com/2023/08/kafka-messaging-with-python-and-polylith.html
* https://www.youtube.com/watch?v=rIt0uj8TaKg
* incentives https://news.ycombinator.com/item?id=36380711&utm_term=comment
* https://www.benkuhn.net/progessays/
* 🗄 notebook 23.01.11
* https://sre.google/sre-book/table-of-contents/ definition of production readiness https://www.thoughtworks.com/radar/techniques?blipid=202203026
* https://news.ycombinator.com/item?id=32319147
* https://www.youtube.com/channel/UCDankIVMXJEkhtjv5yLSN4g/videos
* do with the Golang microservices book https://news.ycombinator.com/item?id=34572263
* https://wafris.org/blog/rearchitecting-for-sqlite https://news.ycombinator.com/item?id=41646775
* https://news.ycombinator.com/item?id=34612919
* https://www.youtube.com/@AsliEngineering/videos
* course on microservices https://www.youtube.com/watch?v=hmkF77F9TLw https://www.youtube.com/watch?v=NVvIpqmf_Xc
* https://brooker.co.za/blog/
* https://runninginproduction.com/podcast/
* db https://news.ycombinator.com/item?id=34434025
* soft delete https://news.ycombinator.com/item?id=32156009 https://brandur.org/soft-deletion https://brandur.org/fragments/deleted-record-insert
* https://www.youtube.com/watch?v=Y-Gl4HEyeUQ
* https://www.youtube.com/watch?v=a2rcgzludDU
* https://jameslittle.me/blog/2020/about-the-guestbook/
* https://benhoyt.com/writings/io-is-no-longer-the-bottleneck/
* https://news.ycombinator.com/item?id=29727707
* https://www.natemeyvis.com/software-design/ https://www.natemeyvis.com/an-argument-from-jimmy-koppel/
* https://simonwillison.net/2022/Feb/9/single-dependency-stacks/
* https://www.semicolonandsons.com/series/learn-system-design-for-web
* https://sirupsen.com/napkin/problem-2
* https://mattsegal.dev/django-prod-architectures.html
* https://github.com/sirupsen/napkin-math https://sirupsen.com/napkin/problem-7
* https://anthonynsimon.com/blog/one-man-saas-architecture/
* https://sirupsen.com/napkin/problem-1
* deploy Django w/ Google Cloud Run https://news.ycombinator.com/item?id=24705668
* https://maheshba.bitbucket.io/blog/2021/10/19/42Things.html
* https://calpaterson.com/bank-python.html
* interviewing https://www.youtube.com/playlist?list=PLrtCHHeadkHptUb0gduz9pxLgvtKWznKj
* rf monitoring re: `link.md` 'speed'
* Kleppmann 1.5 (db, cache, search, MQ)
> ❓ where are you with Kleppmann notes? thought that everything from section 1 has been put into notes, why is there a section for him under 'architecture'?
* https://12factor.net/
* https://increment.com/software-architecture/
* taxonomize https://mattsegal.dev/django-prod-architectures.html
* http://aosabook.org/en/distsys.html
* https://github.com/zachvalenta/nginx-wsgi - general refactor for 1) Poetry 2) Caddy
* https://robertheaton.com/2020/04/06/systems-design-for-advanced-beginners/
* rf 'next'
* security https://www.freecodecamp.org/learn/information-security/information-security-projects/stock-price-checker
* caching https://mattsegal.dev/simple-django-deployment.html
* infra https://mattsegal.dev/simple-django-deployment.html

# 💡 HEURISTICS

* separation of concerns: HTML for content/semantics, CSS for style

## ⭕️ factors

🗄️ `eng.md` factors

---

FACTORS
* throughput, availability
* data immutable (events, analytics)
* memory usage https://news.ycombinator.com/item?id=42244111
* CPU usage https://metoro.io/blog/go-production-performance-gotcha-gomaxprocs

https://gwern.net/choosing-software
* maintenance
* extensible
* popularity

COMPATIBILITY https://thorben-janssen.com/update-database-schema-without-downtime/ 🗄️ `sql.md` migrations
* _backwards compatible_: new code can handle old data 📙 Kleppmann [112]
> is the old data really old?
> e.g. add attr, previous records don't have value for attr but have attr itself
> client/server can just massage data to handle null values
* aka open-closed principle (from SOLID) https://en.wikipedia.org/wiki/Open%E2%80%93closed_principle
* _forward compatibility_: old code can handle new data; typically harder to do 📙 Kleppmann [112] typically old code doesn't touch new fields [129]
> how would this happen unless you logged in

KLEPPMANN
* _reliability_: works even if hw/sw failure [6]
* _scalability_: able to deal w/ growth (data, traffic, complexity)
* _maintainability_: other devs able to work on system
> it is well know that the majority of the cost of software is not in its intial development, but its ongoing maintenance [Kleppmann 18] https://www.jefftk.com/p/designing-low-upkeep-software
* _db on 1 machine_: requires planned downtime [8]
* _db on n machines_: can do rolling upgrade [8]
* _n db_:
* _things that can go wrong_: runaway process (consuming too much memory) [8] unresponsive downstream service [9] operator error [9]
* _how to prevent things going wrong_: testing https://danluu.com/why-benchmark/ easy rollback, monitoring
* _fan out_: num of req to other services to handle one incoming req [11]
📍 need to review SQL of Twitter example
* _evolvability_: ability to change different parts of system independently [Kleppmann 4.128]

## KISS

* hidden control flow, PHP vs. Zig https://news.ycombinator.com/item?id=42203084
* _clarity_: above all bc we're bulding information systems 📻 DHH (STT) https://www.youtube.com/watch?v=9LfmrkyP81M
> And it's not only high performance hardware and software that's complex. Some domains are just really complicated. The tax code is 73k pages long. It's just not possible to reason effectively about something that complicated, and there are plenty of things that are that complicated. https://danluu.com/tests-v-reason/
> I used to tolerate and expect complexity. Working on Go the past 10 years has changed my perspective, though. I now value simplicity above almost all else and tolerate complexity only when it's well isolated, well documented, well tested, and necessary to make things simpler overall at other layers for most people. - Brad Fitzpatrick (Go team member 2010-2020) https://golangweekly.com/issues/533

---

> "Bad engineering" in adhoc ways tends to mean new ideas are being explored. Sophisticated deployments, logistics, procedures, tends to mean you're optimizing or extending existing system. That's not to disparage the latter. making things work at scale is hard engineering. But when people praise the glory days, it may be a preference for working on new ideas in small projects. https://news.ycombinator.com/item?id=41278907

* boring technology https://simonwillison.net/2024/Jul/13/give-people-something-to-link-to/
* aka transitional architecture https://www.thoughtworks.com/radar/techniques?blipid=202203071
> But the cultural tides are strong. Building a company on Django in 2020 seems like the equivalent of driving a PT Cruiser and blasting Faith Hill’s “Breathe” on a CD while your friends are listening to The Weeknd in their Teslas. Swimming against this current isn’t easy, and not in a trendy contrarian way. https://macwright.com/2020/05/10/spa-fatigue.html
* https://martinfowler.com/bliki/Yagni.html https://www.jefftk.com/p/designing-low-upkeep-software
* https://thorstenball.com/blog/2020/09/15/the-context-in-which-we-build-software/
* https://news.ycombinator.com/item?id=26071906
* boring tech has well-understood failure modes https://news.ycombinator.com/item?id=23444594 https://sourcehut.org/blog/2020-06-10-how-graphql-will-shape-the-alpha/
* https://sourcehut.org/blog/2020-06-10-how-graphql-will-shape-the-alpha/
* https://josephg.com/blog/databases-have-failed-the-web/
* https://twitter.com/b0rk/status/1229860328139296768
* https://wizardzines.com/about/
* https://blog.cerebralab.com/Imaginary_Problems_Are_the_Root_of_Bad_Software https://blog.cerebralab.com/Stop_future_proofing_software
* https://blog.cerebralab.com/Bimodal_programming_%E2%80%93_why_design_patterns_fail
* Hickey simple made easy https://news.ycombinator.com/item?id=38433358 https://www.youtube.com/watch?v=LKtk3HCgTa8 data is not easy https://grishaev.me/en/ddd-lie https://news.ycombinator.com/item?id=41290189
* https://www.benkuhn.net/progessays/
* one dev's edge cases are another's entire project 📙 Kleppmann 491
* listen to Knuth -> fast code matters less than you think https://www.youtube.com/watch?v=PhUb7y9WZGs
> We should forget about small efficiencies, say about 97% of the time; premature optimization is the root of all evil. - Donald Knuth
> To be attractive to hackers, a language must be good for writing the kinds of programs they want to write. And that means, perhaps surprisingly, that it has to be good for writing throwaway programs. - http://paulgraham.com/popular.html
* don't cargo cult 'best practices'
> Sophisticated design principles can make your code faster, more flexible, more modular, and all of the other positive adjectives that people use to describe high-quality software. But they also make it more complex. `AbstractSyntaxRenderers` and `DoubleBackflipDatabaseTransmogrophiers` do make some programs clearer and easier to understand, especially large ones. But they can also be the equivalent of using a metrics-oriented, fully agile, stakeholder-prioritized development flow for working on a jigsaw puzzle with your dad. Sure you’re following best practices, but you probably didn’t need to, and now your dad thinks you’re a Scientologist. - https://robertheaton.com/2018/12/02/programming-project-5-snake/
* wait for shared concerns to emerge -> repeat yourself until you find the right abstraction https://programmingisterrible.com/post/176657481103/repeat-yourself-do-more-than-one-thing-and
> There seemed to be a tendency to extract tiny packages first instead of waiting for a shared concern to emerge from the code and only then extracting a package. https://commandercoriander.net/blog/2017/12/31/writing-go/
> The problem with always using an abstraction is that you’re preemptively guessing which parts of the codebase need to change together. “Don’t Repeat Yourself” will lead to a rigid, tightly coupled mess of code. Repeating yourself is the best way to discover which abstractions, if any, you actually need.
> Beware of arguments related to programming speed. All things being equal, faster is better. But all things are never equal. Do you need the kind of speed that lets you get a website up and running quickly? Or the kind that allows you to rotate a few thousand polygons in 3D in real time? Do you need to convert 10,000 PDFs into text per hour? Or 10 million PDFs into text once? These are different problems. - Ford what is code?

## sketching

> In the intersection of the hardware and software industry, we just continuously run into [patterns like this]. A lot of things are defined by finding some process that works, scaling it up 10x and then it breaking in ways that you did not realize things could break. https://www.complexsystemspodcast.com/episodes/boom-busts-and-long-term-progress-with-byrne-hobart-2/

# ⠎ PATTERNS

* top 5 https://www.youtube.com/watch?v=f6zXyq4VPP8
* https://news.ycombinator.com/item?id=26300191
* https://github.com/DovAmir/awesome-design-patterns

WALKTHROUGHS
* https://www.youtube.com/channel/UCDankIVMXJEkhtjv5yLSN4g/videos
* https://www.youtube.com/playlist?list=PL8hP5HjAnJ3_mT7IHXjlbpYX_xiz4v_kP
* Heroku clone https://www.youtube.com/watch?v=zhJLVFR3pE8
* Netflix clone https://www.youtube.com/watch?v=gbyYXgiSgdM
* Facebook clone https://www.youtube.com/watch?v=xSUm6iMtREA
* PagerDuty clone https://www.youtube.com/watch?v=4xuBT3BbsYU alerts https://github.com/keephq/keep

## event-driven 

* https://news.ycombinator.com/item?id=40723302
* https://encore.dev/blog/event-driven-architecture
* https://news.ycombinator.com/item?id=40619521

## layered

## microkernel

## microservices

> Microservices, while often sold as solving a technical problem, usually actually solve for a human problem in scaling up an organization. There's two technical problems that microservices purport to solve: modularization (separation of concerns, hiding implementation, document interface and all that good stuff) and scalability (being able to increase the amount of compute, memory and IO to the specific modules that need it). The first problem, modules, can be solved at the language level. Modules can do that job, and that's the point of this blog post. The second problem, scalability, is harder to solve at the language level in most languages outside those designed to be run in a distributed environment. But most people need it a lot less than they think. Normally the database is your bottleneck and if you keep your application server stateless, you can just run lots of them; the database can eventually be a bottleneck, but you can scale up databases a lot. The real reason that microservices may make sense is because they keep people honest around module boundaries. They make it much harder to retain access to persistent in-memory state, harder to navigate object graphs to take dependencies on things they shouldn't, harder to create PRs with complex changes on either side of a module boundary without a conversation about designing for change and future proofing. Code ownership by teams is something you need as an organization scales, if only to reduce the amount of context switching that developers need to do if treated as fully fungible; owning a service is more defensible than owning a module, since the team will own release schedules and quality gating. I'm not so positive on every microservice maintaining its own copy of state, potentially with its own separate data store. I think that usually adds more ongoing complexity in synchronization than it saves by isolating schemas. A better rule is for one service to own writes for a table, and other services can only read that table, and maybe even then not all columns or all non-owned tables. Problems with state synchronization are one of the most common failure modes in distributed applications, where queues get backed up, retries of "bad" events cause blockages and so on. https://news.ycombinator.com/item?id=34231020

* https://github.com/micro/micro
* = distributed monolith, modularity https://news.ycombinator.com/item?id=31727453
* need more infra knowhow: 5 devs per service https://pythonspeed.com/articles/dont-need-kubernetes/
* https://world.hey.com/dhh/how-to-recover-from-microservices-ce3803cc
* _service layer_: Java-style abstraction https://www.b-list.org/weblog/2020/mar/16/no-service/
* make it a library instead http://catern.com/services.html
* business organization: https://news.ycombinator.com/item?id=23017388
> What microservices let you do is ship your org chart directly, and also map back from some functionality to an owning team. https://news.ycombinator.com/item?id=26247052
* _push_: if receiving svc goes down push svc has to stop
* _pull_: if push svc goes down receiving svc doesn't know (maybe the push svc just doesn't have any messages to push?) set batch size in polling svc (so it pulls when there's, say, 50 msgs vs. on each new msg)
* _sink_: https://www.feval.ca/posts/microservices/ Herman course https://www.zachvalenta.com/notes/2018-feval-microservices.html https://www.vinaysahni.com/best-practices-for-building-a-microservice-architecture https://www.dwmkerr.com/the-death-of-microservice-madness-in-2018/ https://nickjanetakis.com/blog/microservices-are-something-you-grow-into-not-begin-with https://nickjanetakis.com/blog/microservices-are-something-you-grow-into-not-begin-with https://robertnorthard.com/devops-days-well-architected-monoliths-are-okay/ https://segment.com/blog/goodbye-microservices/ https://blogs.dxc.technology/2018/05/08/everything-old-is-new-again-microservices/ https://changelog.com/podcast/312 https://news.ycombinator.com/item?id=22193383
* _benefits_: devs (specialization, experimentation) ergonomics (easier to grok)
* _drawbacks_: no joins (favor document db) outside single process (slower, flaky network) devs (easy code, complex infrastructure) hard to integration test https://aadrake.com/posts/2017-05-20-enough-with-the-microservices.html https://thoughtbot.com/blog/services-are-not-a-silver-bullet
* _communcation_: mq, pub-sub, RPC/REST https://testdriven.io/courses/microservices-with-docker-flask-and-react/part-one-microservices/
* microservices https://entropicthoughts.com/getting-used-to-microservices https://entropicthoughts.com/benefits-of-microservices

## monolith

* monolith + db https://danluu.com/simple-architectures/
> Wave is a $1.7B company with 70 engineers whose product is a CRUD app that adds and subtracts numbers. In keeping with this, our architecture is a standard CRUD app architecture, a Python monolith on top of Postgres. Starting with a simple architecture and solving problems in simple ways where possible has allowed us to scale to this size while engineers mostly focus on work that delivers value to users. Stackoverflow scaled up a monolith to good effect (2013 architecture / 2016 architecture), eventually getting acquired for $1.8B. If we look at traffic instead of market cap, Stackoverflow is among the top 100 highest traffic sites on the internet.
> Despite the unreasonable effectiveness of simple architectures, most press goes to complex architectures. For example, at a recent generalist tech conference, there were six talks on how to build or deal with side effects of complex, microservice-based, architectures and zero on how one might build out a simple monolith. There were more talks on quantum computing (one) than talks on monoliths (zero). Larger conferences are similar; a recent enterprise-oriented conference in SF had a double-digit number of talks on dealing with the complexity of a sophisticated architecture and zero on how to build a simple monolith. Something that was striking to me the last time I attended that conference is how many attendees who worked at enterprises with low-scale applications that could’ve been built with simple architectures had copied the latest and greatest sophisticated techniques that are popular on the conference circuit and HN.
> The cost of our engineering team completely dominates the cost of the systems we operate.
> A place where we can’t be as boring as we’d like is with our on-prem datacenters. When we were operating solely in Senegal and Côte d'Ivoire, we operated fully in the cloud, but as we expand into Uganda (and more countries in the future), we’re having to split our backend and deploy on-prem to comply with local data residency laws and regulations. That's not exactly a simple operation, but as anyone who's done the same thing with a complex service-oriented architecture knows, this operation is much simpler than it would've been if we had a complex service-oriented architecture.
* transistors
> With computing, there have been a couple different cases of scaling breakthroughs. One of them was the discovery of the vacuum tube, where you actually have a device that can do fairly simple logical operations such that you can implement it in a machine. Then we ran into this problem of, the vacuum tubes are mechanical, they do break, and so the bigger your machine, the more likely it is that it breaks; the more complicated your algorithm is, the more likely it is that something breaks down. So you have one of those dynamics where you're scaling your inputs a lot faster than you're scaling your outputs and you're doing things less and less efficiently over time. Then transistors do not actually have moving parts, so they don't have that particular problem – but they run into their own scaling obstacle. It's really fun to read about the early days of this: one of the books that I cite in Boom has an excerpt from, not Scientific American but a magazine of that type in the 50s, where it's speculating that perhaps in the future computers could be the size of a small house, and that's how much we could shrink them. But people ran into this problem with transistors, where the more of them that you connect – and you need all of them to be connected and working for that particular cluster of them to do anything useful – the more of them you connect, the more likely it is that you have one little issue somewhere that makes the whole thing not work. Then it turned out that there was a way around that too, which is that you don't actually plug together individual discrete devices, you actually etch the entire set of connections chemically, and now with many other things – but yeah, you etch it, a one shot [process] where you create one solid thing. That turned out to be a much more scalable architecture. https://www.complexsystemspodcast.com/episodes/boom-busts-and-long-term-progress-with-byrne-hobart-2/

---

* _bikeshedding_: aka yak shaving https://jsonapi.org/ http://bikeshed.org/ https://drewdevault.com/2020/08/17/Engineers-solve-problems.html
> Some applications where you would consider ditching Django to shave off some latency are: a stock trading marketplace; an global online advertisement serving network; a low level infrastructure control API - https://mattsegal.dev/is-django-too-slow.html
> Forget that all these things exist: Microservices, Lambda, API Gateway, Containers, Kubernetes...anything whose main value proposition is about "ability to scale" will likely trade off your "ability to be agile & survive". That’s rarely a good trade off. Start with a t3.nano EC2 instance, and do all your testing & staging on it. It only costs $3.80/mo. Then before you launch, use something bigger for prod, maybe an m5.large (2 vCPU & 8 GB mem). It’s $70/mo and can easily serve 1 million page views per day. https://twitter.com/dvassallo/status/1154516910265884672
> don't waste time on problems you don't have yet 📙 Getting Real [42]
> The bigger problem isn't scaling, it's getting to the point where you have to scale. 📙 Getting Real [42]
> It is well-known that the majority of the cost of software is not in its initial development, but in its ongoing maintenance [Kleppmann 24] Vinsel, Innovation Delusion
> Scaling for many web applications is typically bottlenecked by the database, not the web workers. - https://pythonspeed.com/articles/dont-need-kubernetes/ https://stribny.name/blog/2020/07/scaling-relational-sql-databases
> Build a monolith with copious amounts of telemetry. Use a RDBMS. Use a CDN. Let your telemetry guide you on how to scale, cache, or split your workloads. Don't hire people who want to boil the ocean. https://news.ycombinator.com/item?id=25037628
* just use one big db https://news.ycombinator.com/item?id=31084147
* _vertical scaling_: get faster drives for db
> I am always puzzled about this "autoscale" thing on a cloud. If your task can be represented as something like calculate sum of some ginormous array then sure. Split array in parts and launch thousand instances each working on it's own slice and then combine. In way more common situation you have a service hitting database and doing something with it. Sure you can spin a thousand instances of said service. But they will all be hitting the same database. - https://news.ycombinator.com/item?id=21741870
* _horizontal scaling_: shard https://www.youtube.com/watch?v=7v-wrJjcg4k until recently you waited as long as you could on this 📙 Kleppmann 1.18
> horizontal-scaling is often based on the partitioning of the data i.e. each node contains only part of the data, in vertical-scaling the data resides on a single node and scaling is done through multi-core i.e. spreading the load between the CPU and RAM resources of that machine. With horizontal-scaling it is often easier to scale dynamically by adding more machines into the existing pool - Vertical-scaling is often limited to the capacity of a single machine, scaling beyond that capacity often involves downtime and comes with an upper limit. - https://stackoverflow.com/a/11715598/6813490

# ➖ SERVERLESS

* types: FaaS (Lambda) cloud SQL (BigQuery) ITTT (Zapier) msg (Twilio)
* start: warm (run code) cold (download code, start container, bootstrap runtime, run code) https://www.youtube.com/watch?v=NhDYbskXRgc [1:12:30]
* costs more and runs slower https://einaregilsson.com/serverless-15-percent-slower-and-eight-times-more-expensive/
* saves on devops labor costs https://news.ycombinator.com/item?id=21046547
* bad for local dev https://twitter.com/dvassallo/status/1154516910265884672 
* testing https://buddy.works/tutorials/integration-testing-for-aws-lambda-in-go-with-docker-compose

## baked data

🗄️
* `analytics.md` tooling > BI
* `sql.md` pedagogy

* _baked data_: data embedded as static asset https://simonwillison.net/2020/Dec/13/datasette-io/ https://news.ycombinator.com/item?id=28015980 https://postlight.com/insights/big-data-small-effort
* bc full stack SQL doesn't work https://news.ycombinator.com/item?id=26822884 https://simonwillison.net/2021/Jul/28/baked-data/
* aka flat data https://news.ycombinator.com/item?id=27197950
* query SQLite over HTTP https://github.com/psanford/sqlite3vfshttp
* https://news.ycombinator.com/item?id=31261777 https://adtax.paulromer.net/ https://duckdb.org/2024/10/02/pyodide.html

* _Datasette_: https://csvbase.com/ fetching https://github.com/fatiando/pooch
* _sql.js_: https://github.com/sql-js/sql.js https://selectstarsql.com/frontmatter.html#technicals https://jvns.ca/blog/2019/09/30/notes-on-building-sql-exercises/ https://news.ycombinator.com/item?id=27016630 https://github.com/NUKnightLab/sql-mysteries

* https://news.ycombinator.com/item?id=34558054 https://news.ycombinator.com/item?id=34630153
* https://sqlbolt.com/
* https://dataschool.com/learn-sql/basic-practice/
* https://sql-playground.wizardzines.com/

## no code

🗄 `eng.md` BI

DESIGN
* replaced by AI? https://news.ycombinator.com/item?id=37255363
* provider dependent https://news.ycombinator.com/item?id=37254915
* need off ramp to real source code / runtime https://news.ycombinator.com/item?id=37255299

---

* https://news.ycombinator.com/item?id=28984955
* _automatisch_: Zapier alternative https://github.com/automatisch/automatisch https://tedium.co/2023/03/04/self-hosted-saas-app-alternatives/
* _retool_: https://retool.com/ https://www.youtube.com/watch?v=4xuBT3BbsYU https://www.youtube.com/watch?v=ChTGbmR2NeM
* e.g. build admin panels https://retool.com/blog/building-an-admin-panel-for-your-data-warehouse-in-retool
* wrap and connect APIs https://softwareengineeringdaily.com/2019/12/19/no-code-with-shawn-wang/ aka workflow automation https://github.com/n8n-io/n8n https://news.ycombinator.com/item?id=24648960
* _Tooljet_: https://news.ycombinator.com/item?id=27421408
* _Zapier_ https://softwareengineeringdaily.com/2020/02/27/makerpad-low-code-tools-with-ben-tossell/ https://softwareengineeringdaily.com/2020/02/26/parabola-no-code-data-workflows-with-alex-yaseen/ https://github.com/mkjt2/lockbox
* _Makerpad_: https://makerpad.zapier.com/

## jamstack

* _static site_: content not generated on the fly i.e. no db/server interaction https://wsvincent.com/static-vs-dynamic-a-question-of-layers/
* generators https://github.com/ehouse/kackle https://www.youtube.com/watch?v=ShBD5v6YoNw
* _JAMstack_: static site + APIs
* = dynamism via APIs instead of db https://wsvincent.com/what-is-a-static-site-generator/
* advantages: speed (everything on CDN) security (no db) ++ good for SEO? https://immutablewebapps.org
* 📍 clean up --> https://alexdanco.com/2019/10/26/everything-is-amazing-but-nothing-is-ours/ apparently good for SEO as well Netlify, Gridsome https://redwoodjs.com/ deployment on Zeit, Netlify https://softwareengineeringdaily.com/2020/04/30/jamstack-content-management-with-scott-gallant-jordan-patterson-and-nolan-phillips/ 15:00 https://hacks.mozilla.org/2020/10/mdn-web-docs-evolves-lowdown-on-the-upcoming-new-platform  what it means for backend dev https://www.youtube.com/watch?v=Z2JK7SS82wE https://www.youtube.com/watch?v=grSxHfGoaeg https://scotch.io/@sw-yx/python-the-jamstack

# 🟨 ZA

MOBILE
* https://www.bestinclassiosapp.com/ https://www.swiftjectivec.com/

## Docker db data mgmt

🗄️ `containers.md` volumes
🧠
* https://chatgpt.com/c/673ce340-ca14-8004-b5ee-320faa5c9866
* https://chatgpt.com/c/6724db6b-b820-8004-b8b4-f73f4e6a3c73
* https://chatgpt.com/c/6724c43a-a9cc-8004-809b-2b53075f84af

EXTERNAL
* run Postgres as normal
* Amazon RDS
> 📍 Regarding RDS, you mentioned: "Adds network dependency and potential latency for remote storage." -> Wouldn't that already be the case given that RDS is a service?

VOLUMES
* just save to volume, which persist even if container destroyed
```sh
docker run -d --name postgres -v postgres_data:/var/lib/postgresql/data postgres
```
* backup at intervals
```sh
docker run --rm -v postgres_data:/data -v $(pwd):/backup alpine tar czf /backup/data.tar.gz /data
```
* volume drivers?
> Can you say more about Docker volume drivers?

---

do you have creds for the m

If you're running an app in Docker, and it includes both a backend and a database [let's say Postgres] that it writes to, what are the options for storing that data? Just store in a Docker volume? Save elsewhere?

Let's say that this Dockerized app is hosted on an EC2 instance. How would that change your above assessment?

## semantics

---

* _monolith_: single service, single data store https://news.ycombinator.com/item?id=24505467
* _SOA (service oriented)_: n services, n data stores
* _DOA (data oriented)_: n services, single data store https://blog.eyas.sh/2020/03/data-oriented-architecture/ https://changelog.com/podcast/522

* _architecture_: the stuff that's hard to change
* will change with each order of magnitude i.e. from 1.5k users to 10k 📙 Kleppmann [17,22]
* _node_: process https://leanpub.com/systemdesignmanual/read_sample
* _service_: 1/n nodes providing API https://leanpub.com/systemdesignmanual/read_sample
* _elastic_: scales automatically with load 📙 Kleppmann [17]

* _SOLID_: https://www.youtube.com/watch?v=ywDxJbULcdM
* layered architecture https://blog.europython.eu/kraken-technologies-how-we-organize-our-very-large-pythonmonolith/
> As a general rule of thumb, each layer uses the directly underlying layer to access and interact with the data. As an example, the commands package will not directly use the bug or repository package. It will request the data from the cache layer and go from there. Of course, the commands package will ultimately use types defined in the lower level package like Bug, but retrieving and changing the data has to go through the cache layer to ensure that bugs are properly deduplicated in memory. https://github.com/git-bug/git-bug
* modular https://github.com/gauge-sh/tach https://www.piglei.com/articles/en-6-ways-to-improve-the-arch-of-you-py-project/
> A Python tool to enforce a modular, decoupled package architecture. tach allows you to define boundaries and control dependencies between your Python packages. Each package can define its public interface. If a package tries to import from another package that is not listed as a dependency, tach will report an error. If a package tries to import from another package and does not use its public interface, with strict: true set, tach will report an error. Zero runtime impact. https://pythonbytes.fm/episodes/show/384/force-push-lightly
* beware theologians https://news.ycombinator.com/item?id=26492798
* _patterns_: MVC, hexagonal https://blog.carlmjohnson.net/post/2020/go-cli-how-to-and-advice/ https://netflixtechblog.com/ready-for-changes-with-hexagonal-architecture-b315ec967749 https://www.youtube.com/watch?v=I5c7fBgvkNY
* _resiliency_: perform job through failure https://leanpub.com/systemdesignmanual/read_sample
* Lisp, database inside codebase https://news.ycombinator.com/item?id=26160186 https://feifan.blog/posts/the-database-inside-your-codebase
* _kill switch_: force upgrade mobile app https://simonwillison.net/2021/Jul/1/pagnis/
* _bounded context_: don't let a word mean two different things in the same part of the system ex. 'account' inside primary system vs. 'account' during Paypal integration; again, duh
* _circuit breaker_: error handling https://github.com/Netflix/Hystrix/wiki/How-it-Works https://www.gremlin.com/chaos-monkey/ https://pypi.org/project/circuitbreaker/ https://sirupsen.com/napkin/problem-11-circuit-breakers
* e.g. downstream call fails, return empty list instead of 404 and poll downstream, have limits on resources devoted to downstream
* avoid fault in one part of a system taking down the system
* _coupling_: one change necessitates another
* _horizontal scaling_: aka shared-nothing architecture [Kleppmann 17]
* _multi-tenant_: multiple customer users https://www.saaspegasus.com/
* Edge, Sentry, Parse https://www.youtube.com/watch?v=W1fkGyIcePA&t=1044s https://www.pythonpodcast.com/datacoral-serverless-technology-episode-214/ 15:00-19:00 https://www.youtube.com/watch?v=OfPE7yj1trw https://www.viget.com/articles/multi-tenancy-in-django
* _service mesh_: https://servicemesh.io/ https://news.ycombinator.com/item?id=17415421 https://www.digitalocean.com/community/tutorials/an-introduction-to-service-meshes sidecar, eBPF https://www.thoughtworks.com/radar/techniques?blipid=202203060 Istio
* data mesh https://news.ycombinator.com/item?id=30721198 https://www.thoughtworks.com/radar/techniques?blipid=201911051 https://www.manning.com/books/data-mesh-in-action
* _SSoT_: single source of truth
* _SPoF_: single point of failure
* _fault domain_: components sharing SPoF https://lethain.com/fault-domains/
* _sink_: https://martinfowler.com/architecture/ https://engineering.videoblocks.com/web-architecture-101-a3224e126947
