# ‚õ©Ô∏è

## ÂèÇËÄÉ

üìö
* Barski land of lisp
* Friedman little schemer
* Sussman sicp https://wizardforcel.gitbooks.io/sicp-in-python/content/ https://mitpress.mit.edu/sites/default/files/sicp/index.html https://www.youtube.com/playlist?list=PLE18841CABEA24090 http://www.sicpdistilled.com/ https://xuanji.appspot.com/isicp/ https://corecursive.com/039-hal-abelson-sicp/ https://news.ycombinator.com/item?id=24428907 https://thorstenball.com/blog/2016/11/30/why-i-wrote-a-book-about-interpreters/ https://news.ycombinator.com/item?id=30016323 https://news.ycombinator.com/item?id=42157558

## ËøõÊ≠•

* embedded in Python? https://news.ycombinator.com/item?id=33600941
* Hofstadter https://gist.github.com/jackrusher/5139396
* declarative? üìô Karwin [2]
* _history_: self-perpetuating failure https://news.ycombinator.com/item?id=13143282 Lisp was more awesome in a world w/out Java, Python?
* https://twobithistory.org/2018/10/14/lisp.html
* https://beautifulracket.com/appendix/why-racket-why-lisp.html
* http://jakob.space/blog/thoughts-on-lisps.html
* http://www.paulgraham.com/rootsoflisp.html
* https://treenotation.org/
* https://www.youtube.com/watch?v=1r5GkhoN-Zc
* https://github.com/syncsynchalt/axiomatic-lisp
* https://news.ycombinator.com/item?id=33600941
* https://news.ycombinator.com/item?id=40335608
* https://www.fosskers.ca/en/blog/rounds-of-lisp
* https://gitlab.com/lockie/cl-fast-ecs/-/wikis/tutorial-2 https://news.ycombinator.com/item?id=41869460
* https://en.wikipedia.org/wiki/Steve_Yegge
* mutual interop w/ Java https://blog.cleancoder.com/uncle-bob/2019/08/22/WhyClojure.html
* Golang https://funcall.blogspot.com/2024/10/lisp-vs-golang.html

# üëΩ LISPS

* _Common Lisp_: less Lisp-y, really fast compiler https://news.ycombinator.com/item?id=42671105 https://notes.eatonphil.com/starting-a-minimal-common-lisp-project.html https://ebzzry.io/en/script-lisp/ http://stevelosh.com/blog/2018/08/a-road-to-common-lisp/ http://paulgraham.com/popular.html https://news.ycombinator.com/item?id=32723784 https://borretti.me/article/simplicity-and-survival
* _Fennel_: Lisp built on Lua https://fennel-lang.org/ https://www.mattroelle.com/fennel-the-practical-lisp https://github.com/pluffie/neoproj https://news.ycombinator.com/item?id=43673551
* _Janet_: https://github.com/janet-lang/janet https://github.com/cfoust/cy https://news.ycombinator.com/item?id=42253241
* _Scheme_: lotta different Scheme compilers and Scheme programs are not compatible across different compilers bc the language spec is so minimal (50 pages compared to 650 for Java) https://hardmath123.github.io/perchance-to-scheme.html 

## üü© Clojure

üìö
* Borgatti reference https://www.manning.com/books/clojure-the-essential-reference
> MEAP started December 2016, expected publication 2025!
* Fogus joy of clojure https://www.manning.com/books/the-joy-of-clojure-second-edition
* Higginbotham clojure for the brave and true https://www.braveclojure.com/

USED BY
* https://github.com/damn/core

---

* http://cleancoder.com/a-little-clojure
* https://blog.cleancoder.com/uncle-bob/2019/08/22/WhyClojure.html
* https://news.ycombinator.com/item?id=20844978
* https://tonsky.me/blog/utils/
* http://ahungry.com/blog/2018-12-26-Clojure-is-Capable.html

## üü¶ Racket

üìú https://racket-lang.org/

USED BY
* https://docs.racket-lang.org/pollen/
* https://github.com/DarrenN/cuttlefish
* https://amanvir.com/blog/writing-my-own-dithering-algorithm-in-racket

---

* https://news.ycombinator.com/item?id=42678899
* https://herecomesthemoon.net/2024/11/leetcode-with-racket/
* based off Scheme
* async database https://notes.eatonphil.com/walking-through-a-basic-racket-web-service.html
* https://news.ycombinator.com/item?id=7823337
* https://news.ycombinator.com/item?id=19952714
* https://news.ycombinator.com/item?id=23132621
* https://news.ycombinator.com/item?id=8206038
* https://news.ycombinator.com/item?id=13881535
* https://news.ycombinator.com/item?id=32723784

# ü¶ë RELATIVES

* _Elm_: https://elm-lang.org/examples üóÑÔ∏è `goland.md` CLI > Bubble Tea
* _Scala_: used for Lichess https://news.ycombinator.com/item?id=28479697 https://www.youtube.com/watch?v=7VSVfQcaxFY https://www.scala-lang.org/ https://www.manning.com/books/functional-programming-in-scala-second-edition

## üëæ Elixir

üìú https://elixir-lang.org/
üìö
> use for frontend reads https://grok.com/chat/5761b0d7-100a-48e2-a1b9-6cf32a691d37
> There are systems that aren't a good fit for Elixir. It requires a runtime which immediately eliminates some types of applications. If you want to throw CPU cores at a large data set, process isolation becomes a limitation. The Elixir way is distribution, but despite recent trends, I'd recommend scaling up before scaling out. Related, it doesn't have the best number crunching performance. https://www.openmymind.net/The-Beauty-Of-Elixir-And-Beam/
* web https://pragprog.com/titles/lhelph/functional-web-development-with-elixir-otp-and-phoenix/ https://pragprog.com/titles/liveview/programming-phoenix-liveview/ https://pragprog.com/titles/wmecto/programming-ecto/ https://pragprog.com/titles/puphoe/building-table-views-with-phoenix-liveview/
* https://pragprog.com/titles/alnpee/network-programming-in-elixir-and-erlang/
* https://pragprog.com/titles/passweather/build-a-weather-station-with-elixir-and-nerves/
* https://pragprog.com/titles/sgdpelixir/concurrent-data-processing-in-elixir/
* https://pragprog.com/titles/jgotp/designing-elixir-systems-with-otp/

* _Ecto_: https://news.ycombinator.com/item?id=34936023
* _BEAM_: VM
> Elixir doesn't have threads. It has processes. That can make talking about them a little confusing: am I talking about an Elixir process or an OS process? But as you learn Elixir, you should come to realize: process is a good name for them. Elixir processes only have access to their memory. They can't access another process' memory, nor is there global memory that can be shared between them. Coordination happens via message. If Process A wants access to some of Process B's data, it can ask for it, but it'll only get a copy of the data (in other words, Process B can't break Process A). Elixir processes are boundaries that can be used to make code more cohesive and less coupled. High cohesion and low coupling are still design activities, but you have runtime, library and language support to steer you towards cleaner designs. https://www.openmymind.net/The-Beauty-Of-Elixir-And-Beam/

---

PHOENIX üìú https://www.phoenixframework.org/
* _Phoenix_: Rails
* not that good? https://news.ycombinator.com/item?id=34936023 
> There's a bad kind of magic in Phoenix. It makes heavy use of macros, which I'd say is the only really hard thing to master. https://www.openmymind.net/The-Beauty-Of-Elixir-And-Beam/
* _LiveView_: https://github.com/phoenixframework/phoenix_live_view

* https://dashbit.co/blog/running-python-in-elixir-its-fine
https://livebook.dev/
https://www.openmymind.net/Elixir-A-Little-Beyond-The-Basics/
https://en.wikipedia.org/wiki/Elixir_(programming_language)
* people love Phoenix (Rails-like) https://www.youtube.com/watch?v=RNMwz5n1M80
* _Elixir_: well-liked, good at concurrency/distributed, OTP (stdlib) BEAM (VM), functional https://stackoverflow.com/questions/32807981/what-exactly-is-erlang-otp https://robconery.com/video/how-elixirs-concurrency-changed-me-as-a-programmer/ https://news.ycombinator.com/item?id=28482580 https://news.ycombinator.com/item?id=34934620 main reason to use is Phoneix, and the main reason to use that is LiveView https://joyyo.app/elixir-for-humans-who-know-python https://news.ycombinator.com/item?id=37787805 https://aosabook.org/en/v1/riak.html https://github.com/sile/erldash https://news.ycombinator.com/item?id=42312301 Erlang https://en.wikipedia.org/wiki/Erlang_(programming_language) https://news.ycombinator.com/item?id=43655221
* Erlang https://gleam.run/
* https://www.lambdafunctions.com/articles/elixir-and-rust
* https://www.openmymind.net/Pattern-Matching-In-Elixir/

## üêò Haskell

üìú https://www.haskell.org/
üìö
* Allen https://haskellbook.com/
* Bragilevsky https://www.manning.com/books/haskell-in-depth
* Granin https://www.manning.com/books/functional-design-and-architecture
* Hagenlocher https://www.manning.com/books/learn-haskell-by-example
* Lipovaca https://learnyouahaskell.com/

---

* https://buttondown.com/entropicthoughts/archive/the-greatest-procedural-language-in-the-world-and/
* re: Python https://tcpc.me/2021/12/21/lazy-power-series-integration.html https://unnamed.website/posts/haskelling-my-python/ https://news.ycombinator.com/item?id=43728056
* https://bitbashing.io/haskell-concurrency.html https://news.ycombinator.com/item?id=43679906
* https://gwern.net/resilient-software
* https://news.ycombinator.com/item?id=40702146
* https://news.ycombinator.com/item?id=42754098

## üê™ OCaml

üìú https://ocaml.org/

* guide https://crmarsh.com/intro-to-ocaml/ https://www.youtube.com/watch?v=mhkoWp5Akww https://www.youtube.com/watch?v=FtI5hxDcVKU
* dev env https://crmarsh.com/ocaml-dev-environment/
* design: part of ML family tree, related to F# https://en.wikipedia.org/wiki/ML_(programming_language)
* written in: Google Drive FUSE https://en.wikipedia.org/wiki/Filesystem_in_Userspace#Remote/distributed_file_system_clients
* transpiles to Javascript https://melange.re/v4.0.0/ https://www.youtube.com/watch?v=QrtRihR0Av4
* serde https://www.youtube.com/watch?v=Qs6Di6vjEGs
* https://news.ycombinator.com/item?id=42302426

# üü® ZA

* written in Lisp: ITA, Emacs

## language

* the parens make editing a pain https://news.ycombinator.com/item?id=42766205
* https://zserge.com/posts/langs-lisp/
* _homoiconicity_: code = data https://news.ycombinator.com/item?id=42272433
* with Pythonic syntax https://news.ycombinator.com/item?id=42272433
* little syntax https://blog.cleancoder.com/uncle-bob/2019/08/22/WhyClojure.html
* https://tryclojure.org/
* https://stackoverflow.com/questions/47482349/what-characterizes-a-lisp-dialect
* no loops https://www.lvguowei.me/post/sicp-goodness-looping/
* prefix notation: operator comes first https://www.braveclojure.com/getting-started/

## s expressions

üóÑÔ∏è Ô∏è`algos.md` trees

* = nested list in which the elements are both data and src

---

* XML https://en.wikipedia.org/wiki/S-expression#Parsing
* akin to XML https://en.wikipedia.org/wiki/S-expression#Parsing
* https://news.ycombinator.com/item?id=31840852
* https://news.ycombinator.com/item?id=5654398
* https://notes.eatonphil.com/compiler-basics-lisp-to-assembly.html
* https://news.ycombinator.com/item?id=31840852
